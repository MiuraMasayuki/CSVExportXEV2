using System;
using System.Collections.Generic;
//using System.Linq;
using System.Text;
using Artech.Genexus.Common;
using Artech.Genexus.Common.Helpers;
using Artech.Common.Properties;
using Artech.Genexus.Common.CustomTypes;
using Artech.Architecture.Common.Objects;
using Artech.Architecture.Common.Services;
using Artech.Architecture.UI.Framework.Services;

/*
CSV export pattern(which generates procedure object exporting text-file on GeneXus)
Copyright (C) 2014 Miura Masayuki, GeneXusJapan

contact:
https://marketplace.genexus.com/profile.aspx?masamsa

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */


namespace GXJ.Patterns.CSVExport
{
    public static class CSVExportObjectGeneration
    {
        //Sine code
        public static string GenerateSign()
        {
            //sign
            return "//Generated by CSVExport Pattern";
        }

        //Menu Events
        public static string GenerateCSVExportMenuEvent(CSVExportInstance myInstance)
        {
            string returnvalue = "";
            Artech.Genexus.Common.Objects.Transaction tran = myInstance.ParentObject;
            if (tran != null) {
                if (myInstance.ProcedureObjectForDownload == null)
                {
                    returnvalue += String.Format("msg('There is no setting {0} about procedure object for download.')", myInstance.Name.Trim());
                }
                else
                {
                    returnvalue += String.Format("{0}.Call()", myInstance.ProcedureObjectForDownload.ExportProcedureObjectName);
                }
                return returnvalue;
            }
            else{
                IOutputService output = CommonServices.Output;
                output.AddWarningLine("CSV pattrn Error: Class:CSVExportObjectGeneration");
                returnvalue = "";
                return returnvalue;
            }
        }
        
        //The procedure source
        public static string GenerateCSVExportPrSource(CSVExportInstance myInstance)
        {
            string code1 = "";
            string code2 = "";
            string code3 = "";
            string code4ReplaceMethod = "";
            string code5 = "";
            Artech.Genexus.Common.Objects.Transaction tran = myInstance.ParentObject;

            //before procedure 前処理

            //Stert code property in the incetance
            if (myInstance.ProcedureObjectForDownload.StartCode.Trim() !="")
                code1 += String.Format("{0}\n",myInstance.ProcedureObjectForDownload.StartCode.Trim());

            //File open
            code1 += String.Format("&Filename  = !'{0}' +&WebSession.Id.Trim()  +  !'.{1}'\n", tran.Name, myInstance.ProcedureObjectForDownload.ExportFileExtension.Trim());
            code1 += String.Format("&Checker = DFWOpen(&FileName,!'{0}',!'{1}',0,!'{2}')" + "\n\n", myInstance.ProcedureObjectForDownload.ExportFileSeparator.Trim(), myInstance.ProcedureObjectForDownload.Delimiter.Trim(), myInstance.ProcedureObjectForDownload.ExportFileEncoding.Trim());
    
            //main procedure 主処理

            //For each command
            code2 += "IF &Checker = 0\n";
            code2 +=    "\tFor each\n";

            code3 = "";
            //order section
            if (myInstance.ProcedureObjectForDownload.Order!= null){
                foreach (OrderAttributeElement OAE in myInstance.ProcedureObjectForDownload.Order)
                {
                    if (code3 == ""){
                        code3 += "\t\torder ";
                    }else{
                        code3 += ",";
                    }
                    if (OAE.Ascending == true) {
                        code3 += OAE.AttributeName;
                    }else{
                        code3 += "(" + OAE.AttributeName + ")";
                    }
                }
                code3 += "\n";
            }

            //where section
            if (myInstance.ProcedureObjectForDownload.WhereCode.Trim() != "")
            {
                code3 += String.Format("\t\t{0}\n", myInstance.ProcedureObjectForDownload.WhereCode.Trim());
            }

            //attribute and variable looping
            foreach (ICSVExportInstanceElement IE in myInstance.ProcedureObjectForDownload.Attributes.Items)
            {
                if (IE is GXJ.Patterns.CSVExport.AttributeElement)
                {
                    AttributeElement AE = (AttributeElement)IE;
                    Artech.Genexus.Common.Objects.Attribute trnAtt = AE.Attribute;

                    code4ReplaceMethod = "";
                    switch (trnAtt.Type)
                    {
                        case eDBType.VARCHAR:
                        case eDBType.CHARACTER:
                        case eDBType.LONGVARCHAR:
                            if (myInstance.ProcedureObjectForDownload.ReplaceSeparatorValue)
                                code4ReplaceMethod = String.Format(".Replace(!'{0}',!'{1}')", myInstance.ProcedureObjectForDownload.ExportFileSeparator.Trim(), myInstance.ProcedureObjectForDownload.AlternativeValue.Trim());

                            code3 += String.Format("\t\t&RetNum = DFWPTxt({0}{1}.Trim(),{2})\n", trnAtt.Name.Trim(), code4ReplaceMethod, trnAtt.Length.ToString());
                            break;

                        case eDBType.NUMERIC:
                            code3 += String.Format("\t\t&RetNum = DFWPNum({0},0)\n", trnAtt.Name.Trim());
                            break;

                        case eDBType.DATE:
                            code3 += String.Format("\t\t&RetNum = DFWPDate({0})\n", trnAtt.Name.Trim());
                            break;

                        case eDBType.DATETIME:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt({0}.ToFormattedString())\n", trnAtt.Name.Trim());
                            break;

                        case eDBType.Boolean:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt({0}.ToString().Trim())\n", trnAtt.Name.Trim());
                            break;

                        default:
                            break;
                    }
                }
                else if (IE is GXJ.Patterns.CSVExport.VariableElement)
                {
                    VariableElement VE = (VariableElement)IE;
                    Artech.Genexus.Common.Objects.Domain VD = VE.Domain;

                    if (VE.AssignmentCode.Trim() != "")
                    {
                        code3 += String.Format("\t\t{0}\n",VE.AssignmentCode.Trim());
                    }else{
                        code3 += String.Format("\t\t//Please check Assignment Code property.\n");
                    }
                    switch (VD.Type)
                    {
                        case eDBType.VARCHAR:
                        case eDBType.CHARACTER:
                        case eDBType.LONGVARCHAR:
                            if (myInstance.ProcedureObjectForDownload.ReplaceSeparatorValue)
                                code4ReplaceMethod = String.Format(".Replace(!'{0}',!'{1}')", myInstance.ProcedureObjectForDownload.ExportFileSeparator.Trim(), myInstance.ProcedureObjectForDownload.AlternativeValue.Trim());

                            code3 += String.Format("\t\t&RetNum = DFWPTxt(&{0}{1}.Trim(),{2})\n", VE.Name.Trim(), code4ReplaceMethod, VD.Length.ToString());
                            break;

                        case eDBType.NUMERIC:
                            code3 += String.Format("\t\t&RetNum = DFWPNum(&{0},0)\n", VE.Name.Trim());
                            break;

                        case eDBType.DATE:
                            code3 += String.Format("\t\t&RetNum = DFWPDate(&{0})\n", VE.Name.Trim());
                            break;

                        case eDBType.DATETIME:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt(&{0}.ToFormattedString())\n", VE.Name.Trim());
                            break;

                        case eDBType.Boolean:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt(&{0}.ToString().Trim())\n", VE.Name.Trim());
                            break;

                        default:
                            break;
                    }
                }
            }
            code3 +=        "\t\t&RetNum = DFWNext()\n";

            code2 += code3 ;
            code2 +=    "\tEndfor\n";
            code2 +=    "\t&Checker = DFWClose()\n";
            code2 += "else\n";
            code2 +=    "\tmsg('This application cannot open file.')\n";
            code2 += "endif\n";

            //after procedure 後処理
            
            //Http header
            code5 += "\n";
            code5 += String.Format("&HttpResponse.AddHeader(!'Content-Type', !'{0}')\n", myInstance.ProcedureObjectForDownload.HTTPResponseHeaderContentType.Trim());
            code5 += String.Format("&HttpResponse.AddHeader(!'Content-Disposition', !'attachment;filename='+!'{0}.{1}')\n", tran.Name, myInstance.ProcedureObjectForDownload.ExportFileExtension.Trim());
            code5 += String.Format("&HttpResponse.AddFile(&Filename)");

            //End code property in the incetance
            if (myInstance.ProcedureObjectForDownload.EndCode.Trim() != "")
                code5 += String.Format("\n{0}\n", myInstance.ProcedureObjectForDownload.EndCode.Trim());
            if (myInstance.ProcedureObjectForDownload.SubCode.Trim() != "")
                code5 += String.Format("\n{0}\n", myInstance.ProcedureObjectForDownload.SubCode.Trim());

            return code1 + code2 + code5;
        }

        //The procedure source
        public static string GenerateCSVExportBatchPrSource(CSVExportInstance myInstance)
        {
            string code1 = "";
            string code2 = "";
            string code3 = "";
            string code4ReplaceMethod = "";
            string code5 = "";
            Artech.Genexus.Common.Objects.Transaction tran = myInstance.ParentObject;

            //before procedure 前処理

            //Stert code property in the incetance
            if (myInstance.ProcedureObjectForBatchProcess.StartCode.Trim() != "")
                code1 += String.Format("{0}\n", myInstance.ProcedureObjectForBatchProcess.StartCode.Trim());

            if (myInstance.ProcedureObjectForBatchProcess.ReadINIfile.Trim() == "true")
            {
                code1 += String.Format("//The generated exe file reads INI file which can define export filepath and filename.\n");
                code1 += String.Format("//This text INI file has the following values.\n");
                code1 += String.Format("//<INI Text file sample>\n");
                code1 += String.Format("//   ExportedFilePath = c:\\temp\\  \n");
                code1 += String.Format("//   ExportedFileName = customer.csv \n");
                code1 += String.Format("\n");
                code1 += String.Format("//Ini-file definition\n");
                code1 += String.Format("&INIFilePath = !'{0}' // current directory of execution\n", myInstance.ProcedureObjectForBatchProcess.INIFilePath.Trim());
                code1 += String.Format("&INIFileName = !'{0}'\n", myInstance.ProcedureObjectForBatchProcess.INIFileName.Trim());
                code1 += String.Format("\n");
            }

            code1 += String.Format("//Default value of expoted file when thre is no ini-file\n");
            code1 += String.Format("&ExportedFilepath = !'{0}' // current directory of execution\n", myInstance.ProcedureObjectForBatchProcess.ExportedFilepath.Trim());
            code1 += String.Format("&ExportedFilename = !'{0}'\n", myInstance.ProcedureObjectForBatchProcess.ExportedFilename.Trim());
            code1 += String.Format("\n");

            if (myInstance.ProcedureObjectForBatchProcess.ReadINIfile.Trim() == "true")
            {

                code1 += String.Format("//Checking &INIFilePath \n");
                code1 += String.Format("IF (&INIFilePath.Trim().Length() <> 0)\n");
                code1 += String.Format("\t&Temp = SubStr(&INIFilePath,&INIFilePath.Trim().Length(),1)\n");
                code1 += String.Format("\tIF &Temp <> '\\'\n");
                code1 += String.Format("\t\tmsg('INIFilePath was wrong. This should have backslash at end point.',status)\n");
                code1 += String.Format("\t\treturn\n");
                code1 += String.Format("\tendif\n");
                code1 += String.Format("endif\n");
                code1 += String.Format("\n");
                code1 += String.Format("//INI file process to get target file-path and file-name is the following.\n");
                code1 += String.Format("msg('Ini file opens...',status)\n");
                code1 += String.Format("&Checker = DFROpen(&INIFilePath + &INIFileName,1024,,!'')\n");
                code1 += String.Format("IF &Checker = 0\n");
                code1 += String.Format("\tDo while DFRNext() = 0\n");
                code1 += String.Format("\t\t&RetNum = DFRGTxt(&Temp,1000)\n");
                code1 += String.Format("\t\t//To get generated file path\n");
                code1 += String.Format("\t\tIf &Temp like !'%ExportedFilePath%'\n");
                code1 += String.Format("\t\t\t&RetNum= StrSearch(&Temp,!'=',1)\n");
                code1 += String.Format("\t\t\tIf  &RetNum <>0 \n");
                code1 += String.Format("\t\t\t\t&RetNum +=1\n");
                code1 += String.Format("\t\t\t\t&ExportedFilepath  = SubStr(&Temp,&RetNum,1000)\n");
                code1 += String.Format("\t\t\t\t&ExportedFilepath = &ExportedFilepath.Trim()\n");
                code1 += String.Format("\t\t\t\tExit\n");
                code1 += String.Format("\t\t\tEndif\n");
                code1 += String.Format("\t\tEndif\n");
                code1 += String.Format("\t\t//To get generated file name\n");
                code1 += String.Format("\t\tIf &Temp like '%ExportedFileName%'\n");
                code1 += String.Format("\t\t\t&RetNum= StrSearch(&Temp,!'=',1)\n");
                code1 += String.Format("\t\t\tIf  &RetNum <>0 \n");
                code1 += String.Format("\t\t\t\t&RetNum +=1\n");
                code1 += String.Format("\t\t\t\t&ExportedFilename  = SubStr(&Temp,&RetNum,1000)\n");
                code1 += String.Format("\t\t\t\t&ExportedFilename = &ExportedFilename.Trim()\n");
                code1 += String.Format("\t\t\t\tExit\n");
                code1 += String.Format("\t\t\tEndif\n");
                code1 += String.Format("\t\tEndif\n");
                code1 += String.Format("\tEnddo\n");
                code1 += String.Format("\t&Checker = DFRClose()\n");
                code1 += String.Format("endif\n");
                code1 += String.Format("\n");
                code1 += String.Format("//Checking &ExportedFilepath \n");
                code1 += String.Format("IF (&ExportedFilepath.Trim().Length() <> 0)\n");
                code1 += String.Format("\t&temp = SubStr(&ExportedFilepath,&ExportedFilepath.Trim().Length(),1) \n");
                code1 += String.Format("\tIF  &temp <> '\\'\n");
                code1 += String.Format("\t\tmsg('ExportedFilepath was wrong. This should have backslash at end point.',status)\n");
                code1 += String.Format("\t\treturn\n");
                code1 += String.Format("\tendif\n");
                code1 += String.Format("Endif\n");
                code1 += String.Format("\n");
            }
            
            ////Export file generation 主処理
            code2 += String.Format("//Export file generation\n");
            code2 += String.Format("Msg('Export file generation START',status)\n");
            code2 += String.Format("&Checker = DFWOpen(&ExportedFilepath + &ExportedFilename,!'{0}',!'{1}',0,!'{2}')\n", myInstance.ProcedureObjectForBatchProcess.ExportFileSeparator.Trim(), myInstance.ProcedureObjectForBatchProcess.Delimiter.Trim(), myInstance.ProcedureObjectForBatchProcess.ExportFileEncoding.Trim());
            code2 += "IF &Checker = 0\n";
            //For each command
            code2 += "\tFor each\n";

            code3 = "";
            //order section
            if (myInstance.ProcedureObjectForBatchProcess.Order != null)
            {
                foreach (OrderAttributeElement OAE in myInstance.ProcedureObjectForBatchProcess.Order)
                {
                    if (code3 == "")
                    {
                        code3 += "\t\torder ";
                    }
                    else
                    {
                        code3 += ",";
                    }
                    if (OAE.Ascending == true)
                    {
                        code3 += OAE.AttributeName;
                    }
                    else
                    {
                        code3 += "(" + OAE.AttributeName + ")";
                    }
                }
                code3 += "\n";
            }

            //where section
            if (myInstance.ProcedureObjectForBatchProcess.WhereCode.Trim() != "")
            {
                code3 += String.Format("\t\t{0}\n", myInstance.ProcedureObjectForBatchProcess.WhereCode.Trim());
            }

            //attribute and variable looping
            foreach (ICSVExportInstanceElement IE in myInstance.ProcedureObjectForBatchProcess.Attributes.Items)
            {
                if (IE is GXJ.Patterns.CSVExport.AttributeElement)
                {
                    AttributeElement AE = (AttributeElement)IE;
                    Artech.Genexus.Common.Objects.Attribute trnAtt = AE.Attribute;

                    code4ReplaceMethod = "";
                    switch (trnAtt.Type)
                    {
                        case eDBType.VARCHAR:
                        case eDBType.CHARACTER:
                        case eDBType.LONGVARCHAR:
                            if (myInstance.ProcedureObjectForBatchProcess.ReplaceSeparatorValue)
                                code4ReplaceMethod = String.Format(".Replace(!'{0}',!'{1}')", myInstance.ProcedureObjectForBatchProcess.ExportFileSeparator.Trim(), myInstance.ProcedureObjectForBatchProcess.AlternativeValue.Trim());

                            code3 += String.Format("\t\t&RetNum = DFWPTxt({0}{1}.Trim(),{2})\n", trnAtt.Name.Trim(), code4ReplaceMethod, trnAtt.Length.ToString());
                            break;

                        case eDBType.NUMERIC:
                            code3 += String.Format("\t\t&RetNum = DFWPNum({0},0)\n", trnAtt.Name.Trim());
                            break;

                        case eDBType.DATE:
                            code3 += String.Format("\t\t&RetNum = DFWPDate({0})\n", trnAtt.Name.Trim());
                            break;

                        case eDBType.DATETIME:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt({0}.ToFormattedString())\n", trnAtt.Name.Trim());
                            break;

                        case eDBType.Boolean:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt({0}.ToString().Trim())\n", trnAtt.Name.Trim());
                            break;

                        default:
                            break;
                    }
                }
                else if (IE is GXJ.Patterns.CSVExport.VariableElement)
                {
                    VariableElement VE = (VariableElement)IE;
                    Artech.Genexus.Common.Objects.Domain VD = VE.Domain;

                    if (VE.AssignmentCode.Trim() != "")
                    {
                        code3 += String.Format("\t\t{0}\n", VE.AssignmentCode.Trim());
                    }
                    else
                    {
                        code3 += String.Format("\t\t//Please check Assignment Code property.\n");
                    }
                    switch (VD.Type)
                    {
                        case eDBType.VARCHAR:
                        case eDBType.CHARACTER:
                        case eDBType.LONGVARCHAR:
                            if (myInstance.ProcedureObjectForBatchProcess.ReplaceSeparatorValue)
                                code4ReplaceMethod = String.Format(".Replace(!'{0}',!'{1}')", myInstance.ProcedureObjectForBatchProcess.ExportFileSeparator.Trim(), myInstance.ProcedureObjectForBatchProcess.AlternativeValue.Trim());

                            code3 += String.Format("\t\t&RetNum = DFWPTxt(&{0}{1}.Trim(),{2})\n", VE.Name.Trim(), code4ReplaceMethod, VD.Length.ToString());
                            break;

                        case eDBType.NUMERIC:
                            code3 += String.Format("\t\t&RetNum = DFWPNum(&{0},0)\n", VE.Name.Trim());
                            break;

                        case eDBType.DATE:
                            code3 += String.Format("\t\t&RetNum = DFWPDate(&{0})\n", VE.Name.Trim());
                            break;

                        case eDBType.DATETIME:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt(&{0}.ToFormattedString())\n", VE.Name.Trim());
                            break;

                        case eDBType.Boolean:
                            code3 += String.Format("\t\t&RetNum = DFWPTxt(&{0}.ToString().Trim())\n", VE.Name.Trim());
                            break;

                        default:
                            break;
                    }
                }
            }
            code3 += "\t\t&RetNum = DFWNext()\n";

            code3 += "\tEndfor\n";
            code3 += "\t&Checker = DFWClose()\n";
            code3 += "\tmsg('Export file generation END',status)\n";
            code3 += "else\n";
            code3 += "\tmsg('This application cannot open file.',status)\n";
            code3 += "endif\n";

            //after procedure 後処理
            //End code property in the incetance
            if (myInstance.ProcedureObjectForBatchProcess.EndCode.Trim() != "")
                code5 += String.Format("\n{0}\n", myInstance.ProcedureObjectForBatchProcess.EndCode.Trim());
            if (myInstance.ProcedureObjectForBatchProcess.SubCode.Trim() != "")
                code5 += String.Format("\n{0}\n", myInstance.ProcedureObjectForBatchProcess.SubCode.Trim());

            return code1 + code2 + code3 + code5;
        }

    }
}
